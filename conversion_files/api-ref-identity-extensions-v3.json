{
  "file_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-INHERIT-v3.wadl": "inherit", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-OAUTH1-v3.wadl": "oauth1", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-TRUST-v3.wadl": "trust"
  }, 
  "method_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#createGroup": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#createKey": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#deleteGroup": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#deleteKey": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#generateTicket": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#getGroupKey": "kds"
  }, 
  "resource_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#group-name": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#groups": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#party-name": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#tickets": "kds"
  }, 
  "service": "identity-extensions", 
  "tags": [
    {
      "description": "OS-INHERIT extension (OS-INHERIT)", 
      "name": "inherit", 
      "summary": "Enables projects to inherit role assignments from either their\nowning domain or projects that are higher in the hierarchy.\n\nThe OS-INHERIT extension was extended in API v3.4 to allow\ninheritance from projects in addition to inheritance from domains.\nTo access project inheritance, the Identity service server must run\nat least API v3.4."
    }, 
    {
      "description": "Key Distribution Server (KDS) extension (OS-KDS)", 
      "name": "kds", 
      "summary": "The Key Distribution Server (KDS) is a trusted third party that\ngenerates and securely distributes signing and encryption keys to\ncommunicating parties. These shared keys enable parties to exchange\nauthenticated, confidential messages. KDS is an integral part of\nthe RPC message security implementation. To establish a trusted\nrelationship between the party and the KDS, a properly authorized\nuser, such as a cloud administrator, must assign a long-term shared\nkey to the communicating party. Assigning a key to a party requires\nassigning an identity to that party in the KDS. An identity\nincludes a unique party name and the associated long-term shared\nkey. This party name is used to identify a party when it\ncommunicates with KDS or another party.\n\nThe KDS enables two individual parties or one individual party and\na group party to exchange secure messages. To get keys so that it\ncan communicate with another party, a party makes an authenticated\nrequest to KDS for a ticket. The KDS returns an encrypted ticket to\nthe requesting party. The KDS encrypts the ticket with the long-\nterm shared key that is associated with that party. Only the\nassociated party or the KDS itself can decrypt the ticket.\n\nThe KDS issues a ticket that contains a copy of the shared\nencryption and signing keys. These keys are for the source party,\nwhich is the party that requests the ticket. The ticket also\ncontains a payload that is intended for the destination party,\nwhich is the party with whom the source party wants to communicate.\nThis payload contains the information that the destination party\ncan use to derive the shared encryption and signing keys. When the\ndestination party is:\n\n- An individual. The payload is encrypted with the long-term shared\n  key that is associated with the destination party.\n\n- A group. The payload is encrypted with a shared group key that the\n  KDS makes available to all members of the group. This encryption\n  enables the destination party to trust that the information in\n  the payload was supplied by the KDS.\n\nWhen the source party is ready to communicate with the destination\nparty, it sends this encrypted payload to the destination party\nalong with whatever data it has protected with the shared signing\nand encryption keys. The destination party can decrypt the payload\nand derive the shared encryption and signing keys by using the\npayload information. Both parties have a copy of the shared signing\nand encryption keys that are trusted as being issued by the KDS.\nThe destination party uses these shared keys to authenticate and\ndecrypt the data sent by the source party.\n\nOther guidelines:\n\n- When a source party must send secure messages to multiple\n  recipients, an authorized user can define a KDS group for the\n  recipients. Membership in a group is determined by comparing a\n  party name with the group name. The party is considered to be a\n  member if the party name matches ``< group name > .*`` . For\n  example, a party named ``scheduler.host.example.com`` is\n  considered a member of the ``scheduler`` group. This method is\n  the same method that is used to name message queues in OpenStack.\n\n- When a source party requests a ticket for a destination party that\n  is a group, KDS generates a short-lived group key and assigns it\n  to the group. This group key is used to encrypt the payload in\n  the ticket, which contains the information that the destination\n  party uses to derive the shared signing and encryption keys.\n\n- When an individual destination party must decrypt the payload that\n  it receives from the source party as a part of a group message,\n  it makes an authenticated request to KDS to get the short-lived\n  group key. If the requester is a member of the target group, KDS\n  provides the short-lived group key encrypted with the long-term\n  shared key associated with the individual destination party. The\n  individual destination party can then decrypt the group key,\n  which enables it to decrypt the payload and derive the shared\n  signing and encryption keys to use to authenticate and decrypt\n  the data sent by the source party.\n\n- When a sender gets keys to send a message to a group, all group\n  members and the sender share the signing and encryption keys,\n  which makes it impossible for an individual destination party to\n  determine whether a message was sent by the source party or by\n  another destination party who is a group member. The destination\n  party can confirm only that the message was sent by a party who\n  has the shared signing and encryption keys. When a sender uses\n  keys to send a message to a group, all group members must trust\n  other members to operate in good faith.\n\nThe signing and encryption keys that communicating parties share\nare short-lived. The life span of these keys is defined by a\nvalidity period that is set by the KDS when it issues the ticket. A\nsuggested reasonable default validity period is 15 minutes, though\nthe implementation determines the appropriate validity period.\n\nAfter the validity period for the keys expires, a party should\nrefuse to use those keys to prevent the use of compromised keys.\nThis requires the source party to request a new ticket from the KDS\nto get a new set of keys. An implementation can implement a grace\nperiod to account for clock skew between parties. This grace period\nenables a destination party to accept messages that use recently\nexpired keys. If you use a grace period, its duration should be\nfive or fewer minutes.\n\nA key server, unlike a pure public key-based system, can regulate\nthe encryption and signing key exchange. When keys are requested,\nthe key server actively distributes keys to communicating parties,\napplies access control, and denies communication between arbitrary\npeers in the system. This enables centralized access control,\nprevents unauthorized communication, and eliminates the need to\nperform post-authentication access control and policy lookups on\nthe receiving side.\n\nThe KDS requires that all ticket requests are authenticated and,\nwhere appropriate, data is encrypted. You must pass any time stamp\nvalue to the API as a UTC ISO 8601 date and time string that\nincludes microseconds. For example, ``2012-03-26T10:01:01.720000``\n.\n\nThe default algorithms for message authentication and encryption\nare, respectively, HMAC-SHA-256 and AES-128-CBC. Therefore, the\ndefault block size is 128 bit.\n\nThe source party that requests a ticket must send the encrypted\n``esek`` payload to the destination party. The source and\ndestination strings used when requesting the ticket also must be\nsent to the destination party to enable it to derive the shared\nsigning end encryption keys. The messaging implementation is\nresponsible for transferring this data to the destination party.\n\nThe key derivation used to generate the shared signing and\nencryption keys uses the Hashed Message Authentication Code\n(HMAC)-based key derivation function (HKDF) standard, as described\nin RFC 5869. The destination party must use the HKDF ``expand``\nfunction by using the information that it receives from the source\nparty to complete derivation of the shared signing and encryption\nkeys. The inputs to the HKDF ``expand`` function are:\n\n::\n\n   HKDF-Expand(esek.key, info, 256)\n\nThe ``info`` input for the HKDF ``expand`` function is a string\nthat concatenates the source, destination, and ``esek.timestamp``\nstrings by using a comma ( ``,`` ) separator between each element.\nThe following example shows a valid ``info`` string where\n``scheduler.host.example.com`` is the source,\n``compute.host.example.com`` is the destination, and\n``2012-03-26T10:01:01.720000`` is the ``esek.timestamp`` :\n\n::\n\n   scheduler.host.example.com,compute.host.example.com,2012-03-26T10:01:01.720000\n\nThe output of the HKDF expand function is an array of bytes of 256\nbit length. The first half is the signing key, and the second half\nis the encryption key.\n\nCreate and delete requests for long-term keys are restricted to\nauthorized users, such as cloud administrators. The authentication\nand authorization for these requests is left up to the\nimplementation, though the implementation should leverage the\nIdentity API for these purposes."
    }, 
    {
      "description": "OAuth extension (OS-OAUTH1)", 
      "name": "oauth1", 
      "summary": "Enables users to delegate roles to third-party consumers through\nthe The OAuth 1.0 Protocol .\n\nA user is an Identity API user who delegates its roles and who\nauthorizes request tokens. A consumer is a third-party application\nthat uses OAuth to access a protected resource. An OAuth-derived\ntoken enables admin users to act on behalf of the authorizing user.\nA request token is a token that the consumer uses to get\nauthorization from the user and exchanges with an OAuth verifier\nfor an access token. The OAuth verifier is a required string that\nis provided with the corresponding request token in exchange for an\naccess token. An access token is a token that the consumer uses to\nrequest Identity API tokens on behalf of the authorizing user\ninstead of using the credentials for the user.\n\nRequest and access tokens use token keys to identify themselves.\nFor OpenStack purposes, the token key is the token ID. The consumer\nuses a token secret to establish ownership of a specified token.\nBoth request and access tokens have token secrets.\n\nDelegated authentication through OAuth occurs as follows:\n\n- A user creates a consumer.\n\n\n- The consumer gets an unauthorized request token. Then, the\n  consumer uses the request token to initiate user authorization.\n\n\n- The user authorizes the request token.\n\n\n- The consumer exchanges the authorized request token and the OAuth\n  verifier for an access token.\n\n The authorizing user receives the request token key from the\n  consumer out-of-band.\n\n\n- The consumer uses the access token to request an Identity API\n  token."
    }, 
    {
      "description": "Trust extension (OS-TRUST)", 
      "name": "trust", 
      "summary": "Creates a trust.\n\nA trust is an OpenStack Identity extension that enables delegation\nand, optionally, impersonation through ``keystone`` . A trust\nextension defines a relationship between a trustor and trustee. A\ntrustor is the user who delegates a limited set of their own rights\nto another user. A trustee is the user whose trust is being\ndelegated to, for a limited time.\n\nThe trust can eventually enable the trustee to impersonate the\ntrustor. For security reasons, some safety measures are added. For\nexample, if a trustor loses a given role, any trusts and the\nrelated tokens that the user issued with that role are\nautomatically revoked.\n\nFor more information, see Use trusts ."
    }
  ], 
  "title": "Identity extensions", 
  "version": "v3"
}