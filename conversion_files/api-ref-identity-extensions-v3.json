{
  "file_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-INHERIT-v3.wadl": "inherit", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-OAUTH1-v3.wadl": "oauth1", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-TRUST-v3.wadl": "trust"
  }, 
  "method_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#createGroup": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#createKey": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#deleteGroup": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#deleteKey": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#generateTicket": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#getGroupKey": "kds"
  }, 
  "resource_tags": {
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#group-name": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#groups": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#party-name": "kds", 
    "/home/russell/projects/fairy-slipper-migration/api-site/api-ref/src/wadls/identity-api/src/v3/wadl/OS-KDS-v3.wadl#tickets": "kds"
  }, 
  "service": "identity-extensions", 
  "tags": [
    {
      "description": "OS-INHERIT extension (OS-INHERIT)", 
      "name": "inherit", 
      "summary": "Enables projects to inherit role assignments from either\ntheirowning domain or projects that are higher in the hierarchy.\n\nThe OS-INHERIT extension was extended in API v3.4 to\nallowinheritance from projects in addition to inheritance from\ndomains.To access project inheritance, the Identity service server\nmustrun at least API v3.4."
    }, 
    {
      "description": "Key Distribution Server (KDS) extension (OS-KDS)", 
      "name": "kds", 
      "summary": "The Key Distribution Server (KDS) is a trusted third party\nthatgenerates and securely distributes signing and encryption keys\ntocommunicating parties. These shared keys enable parties\ntoexchange authenticated, confidential messages. KDS is an\nintegralpart of the RPC message security implementation. To\nestablish atrusted relationship between the party and the KDS, a\nproperlyauthorized user, such as a cloud administrator, must assign\nalong-term shared key to the communicating party. Assigning a keyto\na party requires assigning an identity to that party in theKDS. An\nidentity includes a unique party name and the associatedlong-term\nshared key. This party name is used to identify a partywhen it\ncommunicates with KDS or another party.\n\nThe KDS enables two individual parties or one individual party anda\ngroup party to exchange secure messages. To get keys so that itcan\ncommunicate with another party, a party makes an\nauthenticatedrequest to KDS for a ticket. The KDS returns an\nencrypted ticketto the requesting party. The KDS encrypts the\nticket with thelong-term shared key that is associated with that\nparty. Only theassociated party or the KDS itself can decrypt the\nticket.\n\nThe KDS issues a ticket that contains a copy of the\nsharedencryption and signing keys. These keys are for the source\nparty,which is the party that requests the ticket. The ticket\nalsocontains a payload that is intended for the destination\nparty,which is the party with whom the source party wants\ntocommunicate. This payload contains the information that\nthedestination party can use to derive the shared encryption\nandsigning keys. When the destination party is:\n\n- An individual. The payload is encrypted with the long-termshared\n  key that is associated with the destination party.\n\n- A group. The payload is encrypted with a shared group keythat the\n  KDS makes available to all members of the group.This encryption\n  enables the destination party to trustthat the information in the\n  payload was supplied by theKDS.\n\nWhen the source party is ready to communicate with the\ndestinationparty, it sends this encrypted payload to the\ndestination partyalong with whatever data it has protected with the\nshared signingand encryption keys. The destination party can\ndecrypt the payloadand derive the shared encryption and signing\nkeys by using thepayload information. Both parties have a copy of\nthe sharedsigning and encryption keys that are trusted as being\nissued bythe KDS. The destination party uses these shared keys\ntoauthenticate and decrypt the data sent by the source party.\n\nOther guidelines:\n\n- When a source party must send secure messages to\n  multiplerecipients, an authorized user can define a KDS group for\n  therecipients. Membership in a group is determined by comparing\n  aparty name with the group name. The party is considered to be\n  amember if the party name matches ``<group name>.*``.For example,\n  a party named ``scheduler.host.example.com``is considered a\n  member of the ``scheduler``group. Thismethod is the same method\n  that is used to name message queues inOpenStack.\n\n- When a source party requests a ticket for a destination partythat\n  is a group, KDS generates a short-lived group key and assigns\n  itto the group. This group key is used to encrypt the payload in\n  theticket, which contains the information that the destination\n  partyuses to derive the shared signing and encryption keys.\n\n- When an individual destination party must decrypt the payload\n  thatit receives from the source party as a part of a group\n  message, itmakes an authenticated request to KDS to get the\n  short-lived groupkey. If the requester is a member of the target\n  group, KDSprovides the short-lived group key encrypted with the\n  long-termshared key associated with the individual destination\n  party. Theindividual destination party can then decrypt the group\n  key, whichenables it to decrypt the payload and derive the shared\n  signingand encryption keys to use to authenticate and decrypt the\n  datasent by the source party.\n\n- When a sender gets keys to send a message to a group, allgroup\n  members and the sender share the signing andencryption keys,\n  which makes it impossible for anindividual destination party to\n  determine whether amessage was sent by the source party or by\n  anotherdestination party who is a group member. The\n  destinationparty can confirm only that the message was sent by\n  aparty who has the shared signing and encryption keys. Whena\n  sender uses keys to send a message to a group, all groupmembers\n  must trust other members to operate in good faith.\n\nThe signing and encryption keys that communicating parties shareare\nshort-lived. The life span of these keys is defined by avalidity\nperiod that is set by the KDS when it issues the ticket.A suggested\nreasonable default validity period is 15 minutes,though the\nimplementation determines the appropriate validityperiod.\n\nAfter the validity period for the keys expires, a party\nshouldrefuse to use those keys to prevent the use of compromised\nkeys.This requires the source party to request a new ticket from\ntheKDS to get a new set of keys. An implementation can implement\nagrace period to account for clock skew between parties. This\ngraceperiod enables a destination party to accept messages that\nuserecently expired keys. If you use a grace period, its\ndurationshould be five or fewer minutes.\n\nA key server, unlike a pure public key-based system, can\nregulatethe encryption and signing key exchange. When keys are\nrequested,the key server actively distributes keys to communicating\nparties,applies access control, and denies communication between\narbitrarypeers in the system. This enables centralized access\ncontrol,prevents unauthorized communication, and eliminates the\nneed toperform post-authentication access control and policy\nlookups onthe receiving side.\n\nThe KDS requires that all ticket requests are authenticated\nand,where appropriate, data is encrypted. You must pass any time\nstampvalue to the API as aUTCISO8601date and time string that\nincludes microseconds. Forexample, ``2012-03-26T10:01:01.720000``.\n\nThe default algorithms for message authentication andencryption\nare, respectively, HMAC-SHA-256 and AES-128-CBC.Therefore, the\ndefault block size is 128 bit.\n\nThe source party that requests a ticket must send the encrypted\n``esek``payload to the destination party. The source anddestination\nstrings used when requesting the ticket also must besent to the\ndestination party to enable it to derive the sharedsigning end\nencryption keys. The messaging implementation isresponsible for\ntransferring this data to the destination party.\n\nThe key derivation used to generate the shared signing\nandencryption keys uses the Hashed Message Authentication\nCode(HMAC)-based key derivation function (HKDF) standard,\nasdescribed in RFC 5869. The destination party must use the HKDF\n``expand``function by using the information that itreceives from\nthe source party to complete derivation of theshared signing and\nencryption keys. The inputs to the HKDF ``expand``function are:\n\nHKDF-Expand(esek.key, info, 256)The ``info``input for the HKDF ``expand``function is a string that\nconcatenates the source, destination,and ``esek.timestamp``strings\nby using a comma( ``,``) separator between each element. The\nfollowingexample shows a valid ``info``string where\n``scheduler.host.example.com``is the source,\n``compute.host.example.com``is the destination, and\n``2012-03-26T10:01:01.720000``is the ``esek.timestamp``:\n\nscheduler.host.example.com,compute.host.example.com,2012-03-26T10:01:01.720000The output of the HKDF expand function is an array of bytes of\n256bit length. The first half is the signing key, and the second\nhalfis the encryption key.\n\nCreate and delete requests for long-term keys are restricted\ntoauthorized users, such as cloud administrators. The\nauthenticationand authorization for these requests is left up to\ntheimplementation, though the implementation should leverage\ntheIdentity API for these purposes."
    }, 
    {
      "description": "OAuth extension (OS-OAUTH1)", 
      "name": "oauth1", 
      "summary": "Enables users to delegate roles to third-party consumersthrough\ntheThe OAuth 1.0 Protocol.\n\nA user is an Identity API user who delegates its roles and\nwhoauthorizes request tokens. A consumer is a third-party\napplicationthat uses OAuth to access a protected resource. An\nOAuth-derivedtoken enables admin users to act on behalf of the\nauthorizinguser. A request token is a token that the consumer uses\nto getauthorization from the user and exchanges with an OAuth\nverifierfor an access token. The OAuth verifier is a required\nstring thatis provided with the corresponding request token in\nexchange foran access token. An access token is a token that the\nconsumer usesto request Identity API tokens on behalf of the\nauthorizing userinstead of using the credentials for the user.\n\nRequest and access tokens use token keys to identify themselves.For\nOpenStack purposes, the token key is the token ID. Theconsumer uses\na token secret to establish ownership of a specifiedtoken. Both\nrequest and access tokens have token secrets.\n\nDelegated authentication through OAuth occurs as follows:\n\n- A user creates a consumer.\n\n\n- The consumer gets an unauthorized request token.Then, the consumer\n  uses the request token toinitiate user authorization.\n\n\n- The user authorizes the request token.\n\n\n- The consumer exchanges the authorized requesttoken and the OAuth\n  verifier for an accesstoken.\n\n The authorizing user receives the request tokenkey from the\n  consumer out-of-band.\n\n\n- The consumer uses the access token to request anIdentity API\n  token."
    }, 
    {
      "description": "Trust extension (OS-TRUST)", 
      "name": "trust", 
      "summary": "Creates a trust.\n\nA trust is an OpenStack Identity extension that enables\ndelegationand, optionally, impersonation through ``keystone``.\nAtrust extension defines a relationship between a trustor\nandtrustee. A trustor is the user who delegates a limited set\noftheir own rights to another user. A trustee is the user\nwhosetrust is being delegated to, for a limited time.\n\nThe trust can eventually enable the trustee to impersonate\nthetrustor. For security reasons, some safety measures are added.\nForexample, if a trustor loses a given role, any trusts and\ntherelated tokens that the user issued with that role\nareautomatically revoked.\n\nFor more information, seeUse trusts."
    }
  ], 
  "title": "Identity extensions", 
  "version": "v3"
}